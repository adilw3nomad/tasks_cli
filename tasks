#!/usr/bin/env ruby

require 'csv'
require 'optparse'
require 'rainbow'
require 'time'
require 'json'

Rainbow.enabled = true

class Task
  attr_reader :epic, :number, :name, :description, :priority, :status, :relates_to, :blocked_by, :updated_at
  
  def initialize(row)
    @epic = extract_value(row[0])
    @number = extract_value(row[1])
    @name = extract_value(row[2])
    @description = extract_value(row[3])
    @priority = extract_value(row[4])
    @status = extract_value(row[5])
    @relates_to = extract_value(row[6])
    @blocked_by = extract_value(row[7])
    @updated_at = extract_value(row[8]) || Time.now.iso8601
  end

  def extract_value(field)
    return field if field.is_a?(String)
    field.is_a?(Array) ? field[1].to_s.strip : field.to_s.strip
  end

  def to_s
    "#{Rainbow(@number).cyan}: #{Rainbow(@name).bright} (#{status_colored}) - Priority: #{priority_colored} - Updated: #{@updated_at}"
  end

  def detailed_view
    <<~TASK
      #{Rainbow("Epic:").bright} #{@epic}
      #{Rainbow("Number:").bright} #{Rainbow(@number).cyan}
      #{Rainbow("Name:").bright} #{Rainbow(@name).bright}
      #{Rainbow("Description:").bright} #{@description}
      #{Rainbow("Priority:").bright} #{priority_colored}
      #{Rainbow("Status:").bright} #{status_colored}
      #{Rainbow("Relates To:").bright} #{@relates_to}
      #{Rainbow("Blocked By:").bright} #{@blocked_by}
      #{Rainbow("Last Updated:").bright} #{@updated_at}
    TASK
  end

  def to_csv
    [@epic, @number, @name, @description, @priority, @status, @relates_to, @blocked_by, @updated_at]
  end

  def matches?(field, value)
    send(field.to_sym).to_s.downcase.include?(value.to_s.downcase)
  rescue NoMethodError
    false
  end

  def update_timestamp
    @updated_at = Time.now.iso8601
  end

  def status_colored
    case @status.downcase
    when 'to do' then Rainbow(@status).red
    when 'in progress' then Rainbow(@status).yellow
    when 'done' then Rainbow(@status).green
    else Rainbow(@status).white
    end
  end

  def priority_colored
    case @priority.downcase
    when 'high' then Rainbow(@priority).red
    when 'medium' then Rainbow(@priority).yellow
    when 'low' then Rainbow(@priority).green
    else Rainbow(@priority).white
    end
  end
end

class TaskManager
  def initialize(file_path)
    @file_path = file_path
    load_tasks
  end

  def load_tasks
    @tasks = []
    CSV.foreach(@file_path, headers: false) do |row|
      next if row == ["Epic Name", "Ticket Number", "Ticket Name", "Ticket Description", "Priority", "Status", "Relates To", "Blocked By"]
      begin
        parsed_row = row.map do |field|
          parse_field(field)
        end
        @tasks << Task.new(parsed_row)
      rescue => e
        puts "Error processing row: #{row.inspect}"
        puts "Error message: #{e.message}"
      end
    end
  rescue CSV::MalformedCSVError => e
    puts Rainbow("Error reading CSV: #{e.message}. Trying to parse with alternative method...").red
    parse_csv_manually
  rescue => e
    puts Rainbow("Unexpected error while loading tasks: #{e.message}").red
    puts e.backtrace
  end

  def parse_field(field)
    return field unless field.start_with?('[') && field.end_with?(']')
    parsed = JSON.parse(field.gsub('=>', ':'))
    [parsed[0], parsed[1]]
  rescue JSON::ParserError
    [nil, field]
  end

  def parse_csv_manually
    @tasks = []
    lines = File.readlines(@file_path)
    lines[1..-1].each do |line|
      fields = line.strip.split(',')
      parsed_fields = fields.map { |field| parse_field(field) }
      @tasks << Task.new(parsed_fields)
    rescue => e
      puts "Error processing line: #{line}"
      puts "Error message: #{e.message}"
    end
  end

  def save_tasks(task_number)
    lines = File.readlines(@file_path)
    File.open(@file_path, 'w') do |file|
      file.puts lines[0].chomp  # Write header as is
      lines[1..-1].each do |line|
        fields = line.strip.split(',').map { |f| parse_field(f) }
        if fields[1][1] == task_number
          task = find_task(task_number)
          updated_line = task.to_csv.map { |value| [fields[_1][0], value].to_s }.join(',')
          file.puts updated_line
        else
          file.puts line.chomp  # Write unchanged lines as is
        end
      end
    end
  end

  def all_tasks
    @tasks
  end

  def filter_tasks(criteria)
    @tasks.select do |task|
      criteria.all? { |field, value| task.matches?(field, value) }
    end
  end

  def find_task(number)
    @tasks.find { |task| task.number == number }
  end

  def update_status(number, new_status)
    task = find_task(number)
    if task
      old_status = task.status
      task.instance_variable_set(:@status, new_status)
      task.update_timestamp
      save_tasks(number)
      puts Rainbow("Updated status of task #{number} from #{old_status} to #{new_status}").green
      puts Rainbow("Last updated: #{task.updated_at}").cyan
    else
      puts Rainbow("Task not found").red
    end
  end
end

def print_tasks(tasks)
  if tasks.empty?
    puts Rainbow("No tasks found.").yellow
    return
  end

  puts Rainbow("\n%-10s %-30s %-15s %-10s %-25s" % ["Number", "Name", "Status", "Priority", "Last Updated"]).underline
  tasks.each do |task|
    puts "%-10s %-30s %-15s %-10s %-25s" % [
      Rainbow(task.number).cyan,
      Rainbow(task.name.to_s.truncate(30)).magenta,
      task.status_colored,
      task.priority_colored,
      Rainbow(task.updated_at).blue
    ]
  end
  puts "\nTotal tasks: #{Rainbow(tasks.count).green}"
end

# Main program
if __FILE__ == $0
  begin
    file_path = File.expand_path('~/tasks.csv')  # Store the CSV in the user's home directory
    manager = TaskManager.new(file_path)

    options = {}
    OptionParser.new do |opts|
      opts.banner = "Usage: tasks [options]"

      opts.on("-a", "--all", "View all tasks") do
        options[:all] = true
      end

      opts.on("-f FIELD:VALUE", "--filter FIELD:VALUE", "Filter tasks by field and value (can be used multiple times)") do |f|
        options[:filter] ||= {}
        key, value = f.split(':')
        options[:filter][key] = value
      end

      opts.on("-v NUMBER", "--view NUMBER", "View a single task") do |v|
        options[:view] = v
      end

      opts.on("-u NUMBER,STATUS", "--update NUMBER,STATUS", Array, "Update a task's status") do |u|
        options[:update] = u
      end
    end.parse!

    if options[:all]
      print_tasks(manager.all_tasks)
    elsif options[:filter]
      print_tasks(manager.filter_tasks(options[:filter]))
    elsif options[:view]
      task = manager.find_task(options[:view])
      if task
        puts task.detailed_view
      else
        puts Rainbow("Task not found").red
      end
    elsif options[:update]
      number, status = options[:update]
      manager.update_status(number, status)
    else
      puts Rainbow("No valid option provided. Use -h for help.").yellow
    end
  rescue Errno::ENOENT
    puts Rainbow("Error: CSV file '#{file_path}' not found. Please ensure the file exists.").red
  rescue => e
    puts Rainbow("An unexpected error occurred: #{e.message}").red
    puts e.backtrace
  end
end